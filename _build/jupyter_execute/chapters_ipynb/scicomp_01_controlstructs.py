#!/usr/bin/env python
# coding: utf-8

# # Control structures, numerical integration

# ## Recap
# 
# Hello and welcome back to our introduction to computation for the physical sciences using `python`!  You'll recall that in our last lesson we worked with some of the basic capabilities of `python` and Jupyter notebooks:
# 1. Jupyter notebooks: allow us to combine markdown cells (like this one) with code cells (that actually execute `python` code).
# 1. Basic mathematical operations: `+, - , *, /`
# 1. Variable declaration and storing numerical values in variables.  This is done with the `=` operator.
# 1. Basic run-time errors.  If your code doesn't run, `python` sometimes offers helpful error reports.
# 1. Function definition using keywords `def` and `return`.
# 1. Basic loop structure using keyword `for`.
# 
# The last of these we covered only so that you could start doing some interesting problems.  In this lesson, we'll cover *control structures* more broadly.

# 
# ## Motivation
# 
# Before we get started, let's look at a few applications of computational science.  Check these out:
# - [GAN for face generation](https://www.youtube.com/watch?v=kSLJriaOumA)
# - [SegNet, a DC-autoencoder for image segmentation](https://www.youtube.com/watch?v=CxanE_W46ts)
# - [Mandelbrot Set "hard zoom"](https://www.youtube.com/watch?v=jm_Q1FO9bP4). The Mandelbrot set is generated by iterating the operation $f_c(z) = z^2 + c$ beginning with $z = 0$.  The *complex* number $c$ is in the Mandelbrot set if this iteration eventually settles to zero.
# 
# Really cool applications that simply are *not* possible without computers.

# ***
# 
# ## Control structures: Loops
# 
# *Control structures* are programming structures (functions or ways of combining functions) that... um... control the way that our code will run.  Broadly, control structures allow us to make the computer do repetitive tasks (*loops*) and allow us to make the computer's behavior depend on parameters in our calculation or other inputs (*conditionals*).
# 
# Let's start with **loops**.  We use a loop when we need to perform some task over and over and over and over again.  In the previous lesson we talked about *why* it is a good thing that we have computers to do this mindless work for us.  The vast majority of the calculations we do in the physical sciences are doable with pencil and paper -- however, the manual approach would take so long that these calculations would be *effectively* impossible.  The automation of such calcultions with computers has advanced science a great deal since the 1940s!  For an example, check out the [history of the cracking of the German Enigma machine](https://www.youtube.com/watch?v=G2_Q9FoD-oQ&ab_channel=Numberphile).
# 
# Where loops are concerned, we distinguish between two types of implementations/calculations:
# - **Iteration** -- the simplest type of loop calculations, performing a repetitive task over and over, say $N$ times.  In an iteration problem, we could in principle begin our calculations anywhere in the series of calculations.  In Lesson 0 we saw an interation problem where we added up all of the numbers between 0 and 2022.
# - **Recursion** -- this is more challenging type of loop where the $n+1$th calculation depends on the results of the $n$th calculation.  For a recursion problem, we can't simply start wherever; we need to do the calculation in order and keep track of the values at each step in the process.
# 
# There are two basic types of loop control structures: definite and indefinite.
# 
# ***
# 
# ### Definite Loops, `for`
# 
# A definite loop is one that must happen a fixed number of times, AND we *know* this number of times before we begin running our program.  In `python`, this is most easily/compactly achieved with the `for` loop.  A `for` loop performs the tasks inside of the loop FOR (get it?) a fixed number of times.  The syntax for writing a `for` loop in python looks like this:

# In[1]:


for i in range(10):
    print(i)
    
print("Now we are done!")


# Several features are worth commenting on:
# - The indentation tells python what instructions happen "inside" the loop.  The first line that's not indented is not part of the loop.
# - Note the colon (`:`) in this syntax.  The colon works like it does in english syntax: "Hey, computer, do the following things: print 0, print 1, print 2, print 3, ..."  
# - Note that the stuff that the computer does in the loop doesn't change; rather, it's the value of the variable `i` that is changing!
# - `range()` is a compact way of setting the parameters of a `for` loop.  `range(N)` generates a list of numbers between 0 and `N-1`.  Note that this default behavior considers the "first ten integers" to be the numbers 0 through 9.
# 
# The defining characteristic of a `for` loop is that the loop behavior is *hard coded* into the loop.  (Without any additional code) You could read the program and know how many times it will execute.
# 
# ***
# 
# Even though the syntax is basic, there are many interesting ways to use a `for` loop.  In our previous lesson you saw how we used `for` to sum series, compute interest, and map out the values of a polynomial function.
# 
# Note that we often want our loop to access quantities/variables that are defined *outside* of the loop.  You did this before, but let's do an example to refresh our memory.
# 
# #### Warm-up problem
# Add up the even number between 0 and 2022.

# In[2]:


# code goes here, McCracken!


# ### Indefinite Loops
# 
# An *indefinite* loop is a loop for which we can't hard-code the number of iterations.  This might seem odd, but examples aren't too difficult to come by.  For example, what if I deposited \\$100 into the bank at a 3.0\% annual interest rate.  How long do I have to wait until it becomes \\$1000?  Well, we would code up the calculation in a way similar to how we did it in Lesson 0, but we want the loop to stop looping once the value exceeds \\$1000...  How long will this take?  I don't know (yet)!
# 
# The control structure associated with indefinite loops is the `while` loop. A `while` structure performs the operations in the loop *as long as a specified condition is true*.  We usually have to have some external stuff for a `while` loop to compare to:

# In[3]:


loopmax = 10
loopcount = 0
while loopcount <= loopmax:
    print("Mikey likes bikes")
    loopcount = loopcount + 1


# This is a glorious waste of computing power, but it demonstrates how a tedious task can be left to a computer.  
# 
# In the `while` structure, the stuff that comes after `while` is the condition that `python` will check each time through the loop.  When writing a condition, we typically use the following *comparison operations*:
# - `<`, `>`, `<=`, `>=` are your old pals
# - '==' (double equals sign) checks to see if two values are equal to one another
# - '!=' checks to see if two values are not equal to one another
# - the `not` keyword negates whatever clause follows it
# When you perform a comparison in `python`, it acts like a function that returns either `True` or `False`.
# 
# Take a look at these:

# In[4]:


2 < 1, 2 > 1, 2 == 1, 2 != 1, not 2 > 1


# Another way to think of `while` loops is using them to figure out how many iterations are necessary to do something.  Check this out: What if I deposit \\$1000 in the bank at 2.1\% interest per year?  How many years will it take before I have \\$1000000 megadollars in the bank?

# In[5]:


deposit = 1000
interest = 0.021
year = 0
while deposit < 1000000:
    deposit = deposit * (1.0 + interest)
    year = year + 1

print(year)


# Of course, there is a simpler way to do this calculation, but this is just a demonstration.  We can check with:  

# In[6]:


(1.021**333)*1000


# Looks legit.  Interest calculations like this are pretty simple to figure out, but there are some systems, called non-linear systems, for which analytical (*i.e.*, pen and paper) calculations are just not possible.  We'll study some of these later on!  COOL.
# 
# One thing that's worth noting is that the loop in the interest example is essentially calculating an integral.  If you can remember back to your old Simpson's method days from Calc I, you'll recognize that computers would be really good at adding up the areas of rectangles.
# 
# ### Iteration vs Recursion revisited
# 
# Most loop implementations perform **iteration**; that is, they iterating over a number of values.  The definite loops that we've seen so far have been pretty basic in that they're simply iterating over sequential integers.  In the future, we'll see how to iterate over more general lists of values.
# 
# In some cases, and this is usually true of `while` loop implementations, the current calculation of the loop depends on a calculation done in the previous instance of the loop.  Said another way, each time we go through the loop, we produce some values that are used the *next* time the loop is executed.  This process is called **recursion**, and the loop and it's calculation are said to be **recursive**.  The interest calculation that we did above (with a loop) is a recursive calculation because the balance in year $n$ depends on the balance in the year $n-1$.
# 
# This might just seem like fancy language right now, but these distinctions will help you to organize your throughts later.

# ***
# 
# ## Conditionals 
# 
# ### If statements
# 
# Okay, one last thing to do in Lesson 1: `if` statements.  `python` is good at checking whether statements are true or false.  We saw some of the comparison operators in the previous section on `while` loops.

# Often we want our programs to perform different behaviors based on whether conditions are met.  This type of structure, which checks a condition and then performs some actions based on the condition, is called a **conditional**.  There are several ways to make conditionals, but we can do a lot with `if` for the time being.
# 
# Hey, I bet we can finally check to see whether numbers are off or even!  (We'll need to look up the `%` operator):

# In[7]:


for i in range(10):
    if i % 2 == 0:
        print(i, "is even")


# Wow, call the Math Department!
# 
# We can also use the `else` and `elif` ('else if' keywords) in situations where there are multiple conditions to check.  Let's try them out!

# In[8]:


for i in range(10):
    if i % 2 == 0:
        print(i, "is even")
    elif i % 3 == 0:
        print(i, "is not even but is divisible by 3")
    else:
        print(i, "is neither even nor divisible by 3")         


# ***
# 
# See if you can figure out how this snippet works.

# In[9]:


ndivby7 = 0
ndivby11 = 0
for i in range(1,100):
    if i**3 % 7 == 0:
        print(i, i**3)
        ndivby7 = ndivby7 + 1
    elif i**3 % 11 == 0:
        print(i, i**3)
        ndivby11 = ndivby11 + 1

print()
print("We found", ndivby7, "cubes divisible by 7")
print("We found", ndivby11, "cubes divisible by 11")


# Nice.
# ***
# 
# ## Numerical integration
# 
# With `while`, we can implement a simple integration technique.  In calculus classes, you encountered many very impressive rules and forms for integrating common functions.  Wow, so great.  But what if you have to compute a definite integral of a function that doesn't match one of the rules or forms???  
# 
# *Numerical integration* is a technique for computing the area under a function by summing up the areas of little teeny chunks of this area.  If you think back to your Calc I days, the numerical integration approach below is basically a Riemann sum.
# 
# Let's integrate a nasty function that comes up all the time in the sciences: a gaussian:
# \begin{equation}
#   g(x) = \frac{1}{\sqrt{2\pi\sigma^2}}\exp\left[ {-\frac{(x - \mu)^2}{2\sigma^2}}\right]
# \end{equation}
# 
# Let's let $\mu = 0$ and $\sigma = 0.5$.  [I'll draw it on the board.]  For now, nevermind what this function is and does; just know that it's a real bear to integrate.  We're going to integrate this function from $x_1 = -0.5$ to $x_2 = 0.5$.
# 
# There's a lot of sophisticated math stuff in this function, so we're going to import a **library** called `numpy` ("numerical python") that will give us access to help.  `numpy` is a huge library with some great tools in it; we'll use it often!  Here, we'll use `numpy` to give us precise values of $\pi$ and the exponential function.

# In[10]:


import numpy
print(numpy.pi)
print(numpy.e)


# In[11]:


def our_gaussian(x):
    mu = 0.0
    sigma = 0.5
    coeff = 1 / numpy.sqrt(2 * numpy.pi * sigma**2)
    exponent = - (x - mu)**2 / 2 / sigma**2
    return coeff * numpy.exp(exponent)


# In[12]:


x = -0.5
x2 = 0.5
dx = 0.001
integral = 0

while x <= x2:
    integral = integral + our_gaussian(x) * dx
    x = x + dx
    
print(integral)


# We call `dx` the integration step -- it sets the widths of the rectangles that we use to approximate the area under the function.  If `dx` is large, our calculation will take very few steps (and be quick), but the approximation will be lousy.  What if `dx` is very smol?
# 
# The approach to integration demonstrated above is a very powerful tool in the sciences.  Many computational simulations of physical systems (you know, like the entire video game industry) are nothing more than numerical integration of Newton's Second Law.  We'll get into this later in the course.

# * * *
# ## Problems
# 
# Your homework is to complete 4 of the following problems.  You do *not* have to do all of the problems below.
# 
# ### Regulars
# 
# 1. Write a program that counts the number of perfect squares (cubes?) between 1 and 1000000.  Note that there are *at least* two ways to do this.  Is this iteration of recursion?
# 1. Write a program that computes the first 900 numbers in the Fibonacci sequence.  Recall/behold that the $n^\textrm{th}$ Fibonacci number, $f_n$, is given by
# \begin{equation}
# f_n = f_{n-2} + f_{n-1} 
# \end{equation}
# with the specification that $f_0 = 0$ and $f_1 = 1$. Said another way, we get each number in the Fibonacci sequence by adding the two that precede it.  Your program should also calculate the ratio $f_i / f_{i-1}$. For each number in the sequence.
# 1. Write a program that computes the integral 
# \begin{equation}
#   \displaystyle\int_{0}^{8\pi} \cos^{4}(x^3)\; dx.
# \end{equation}
# How small does your `dx` have to be to get within 0.01\% of the analytical solution, $\frac{3\pi}{4}$?
# 1. A lake has 2500 ducks on it in year 0.  In each "normal" year, the duck population increases by 6.2\%.  However, if the population goes over 3201, the lake gets too crowded and 1428 duck move to another lake.  If the number of ducks is below 2500, there is abundant food and the number of ducks increases by 8.9\% annually.  Find the number of ducks on the lake in the year 3000.  Your program should print to screen the duck population each year.
# 
# ### Meanies
# 
# 5. Write a program that finds all Pythagorean triples $(a, b, c)$, such that $a+b+c < 4342$.  Recall that three integers form a Pythagorean triple if $a^2 + b^2 = c^2$.
# 5. Write a function, `is_prime(n)`, that determines whether the number `n` is prime. Use this function in a program that finds the first 100 prime numbers.  Can you make this process more efficient? How long does it take to find the first 1000 prime numbers?
# 
